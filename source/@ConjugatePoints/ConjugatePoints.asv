classdef ConjugatePoints 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           Class properties.                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    properties( Access = public )

        conjPts = [];         % struct containing data associated to the conjugate points  
        vfParams = [];         % Parameters for the vector field
        Euminus = []; 
    end
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             Constructor.                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     
    
    methods( Access = public, Static = false )
        
        function C = ConjugatePoints(conjPts, vfParams)
         
            % Store approximation order.
            [vectors, values]= getBinfEigs(C);
            isLagrangian = verifyLagrangian(C, frame);

            [full_phi1, frame] = generateEuFrame(C);
            
            % Store parameters for the vector field.
            S.vfParams = vfParams;

            % Store value of normal form branch 
            allowedBranchValues = [0,pi];
            if (ismember(normalForm.branch, allowedBranchValues) == 1) == 0
                error('The branch value is invalid. Please choose branch value 0 or pi.')
            end
            S.normalForm = normalForm;
            
            % Store temporal domain, should be a positive number for domain
            % [-L, L] 
            S.time = time;
                                    
            
        end
        
    end
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              Methods.                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    methods( Access = public, Static = false )
        
        % Normal form solution via Burke and Knobloch 
        S = BKNormalForm4d_halfline(S)

        % Get normal form solution with Dirichlet/Neumann BC 
        S = trimNFSol_halfline(S);

        % Get fourier coefficients from BK normal form solution 
        S = getFullFourierCoeffs(S, sol, interval_type)

        % Perform Newton's method 

        S = Newton_halfline(S); 
        S = Newton(S)

        % helper methods, could be made private 
        % helper method to recover function from Fourier coefficients 
        solution = getFunctionFromFourierCoeffs(S, coeffs, time_vec)
        jacobian = DFFourier(S, a)
        fourier_vf = fourierODE(S, a)


                                    
    end   
    methods( Access = public, Static = true )
                
        
                                    
    end   
    
end

